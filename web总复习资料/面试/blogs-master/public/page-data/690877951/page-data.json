{"componentChunkName":"component---src-templates-blog-post-js","path":"/690877951/","result":{"data":{"site":{"siteMetadata":{"title":"ssh的博客","author":"ssh"}},"markdownRemark":{"id":"55db3d39-48e2-5246-a46b-1beacf86a135","html":"<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>如果让你手写async函数的实现，你是不是会觉得很复杂？这篇文章带你用20行搞定它的核心。  </p>\n<p>经常有人说async函数是generator函数的语法糖，那么到底是怎么样一个糖呢？让我们来一层层的剥开它的糖衣。  </p>\n<p>有的同学想说，既然用了generator函数何必还要实现async呢？  </p>\n<p>这篇文章的目的就是带大家理解清楚async和generator之间到底是如何相互协作，管理异步的。</p>\n<h2 id=\"示例\"><a href=\"#%E7%A4%BA%E4%BE%8B\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>示例</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getData</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span>resolve <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"data\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data: '</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> data2 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data2: '</span><span class=\"token punctuation\">,</span> data2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'success'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 这样的一个函数 应该再1秒后打印data 再过一秒打印data2 最后打印success</span>\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"思路\"><a href=\"#%E6%80%9D%E8%B7%AF\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>思路</h2>\n<p>对于这个简单的案例来说，如果我们把它用generator函数表达，会是怎么样的呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">testG</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// await被编译成了yield</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data: '</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> data2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data2: '</span><span class=\"token punctuation\">,</span> data2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'success'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>我们知道，generator函数是不会自动执行的，每一次调用它的next方法，会停留在下一个yield的位置。  </p>\n<p>利用这个特性，我们只要编写一个自动执行的函数，就可以让这个generator函数完全实现async函数的功能。  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getData</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span>resolve <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"data\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  \n<span class=\"token keyword\">var</span> test <span class=\"token operator\">=</span> <span class=\"token function\">asyncToGenerator</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">testG</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// await被编译成了yield</span>\n      <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data: '</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> data2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data2: '</span><span class=\"token punctuation\">,</span> data2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">'success'</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>那么大体上的思路已经确定了，  </p>\n<p><code class=\"language-text\">asyncToGenerator</code>接受一个<code class=\"language-text\">generator</code>函数，返回一个<code class=\"language-text\">promise</code>，  </p>\n<p>关键就在于，里面用<code class=\"language-text\">yield</code>来划分的异步流程，应该如何自动执行。  </p>\n<h2 id=\"如果是手动执行\"><a href=\"#%E5%A6%82%E6%9E%9C%E6%98%AF%E6%89%8B%E5%8A%A8%E6%89%A7%E8%A1%8C\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>如果是手动执行</h2>\n<p>在编写这个函数之前，我们先模拟手动去调用这个<code class=\"language-text\">generator</code>函数去一步步的把流程走完，有助于后面的思考。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">testG</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// await被编译成了yield</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data: '</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> data2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data2: '</span><span class=\"token punctuation\">,</span> data2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'success'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>我们先调用<code class=\"language-text\">testG</code>生成一个迭代器</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 返回了一个迭代器</span>\n<span class=\"token keyword\">var</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">testG</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>然后开始执行第一次<code class=\"language-text\">next</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 第一次调用next 停留在第一个yield的位置</span>\n<span class=\"token comment\">// 返回的promise里 包含了data需要的数据</span>\n<span class=\"token keyword\">var</span> dataPromise <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这里返回了一个<code class=\"language-text\">promise</code>，就是第一次<code class=\"language-text\">getData()</code>所返回的<code class=\"language-text\">promise</code>，注意</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这段代码要切割成左右两部分来看，第一次调用<code class=\"language-text\">next</code>，其实只是停留在了<code class=\"language-text\">yield getData()</code>这里，  </p>\n<p><code class=\"language-text\">data</code>的值并没有被确定。</p>\n<p>那么什么时候data的值会被确定呢？</p>\n<p><strong>下一次调用next的时候，传的参数会被作为上一个yield前面接受的值</strong></p>\n<p>也就是说，我们再次调用<code class=\"language-text\">gen.next(&#39;这个参数才会被赋给data变量&#39;)</code>的时候  </p>\n<p><code class=\"language-text\">data</code>的值才会被确定为<code class=\"language-text\">&#39;这个参数才会被赋给data变量&#39;</code>  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token string\">'这个参数才会被赋给data变量'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 然后这里的data才有值</span>\n<span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 然后打印出data</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data: '</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 然后继续走到下一个yield</span>\n<span class=\"token keyword\">const</span> data2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>然后往下执行，直到遇到下一个<code class=\"language-text\">yield</code>，继续这样的流程…</p>\n<p>这是generator函数设计的一个比较难理解的点，但是为了实现我们的目标，还是得去学习它~  </p>\n<p>借助这个特性，如果我们这样去控制yield的流程，是不是就能实现异步串行了？</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">testG</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// await被编译成了yield</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data: '</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> data2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data2: '</span><span class=\"token punctuation\">,</span> data2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'success'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">testG</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">var</span> dataPromise <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\ndataPromise<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// data1的value被拿到了 继续调用next并且传递给data</span>\n    <span class=\"token keyword\">var</span> data2Promise <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">)</span>\n    \n    <span class=\"token comment\">// console.log('data: ', data);</span>\n    <span class=\"token comment\">// 此时就会打印出data</span>\n    \n    data2Promise<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// data2的value拿到了 继续调用next并且传递value2</span>\n         gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">)</span>\n         \n        <span class=\"token comment\">// console.log('data2: ', data2);</span>\n        <span class=\"token comment\">// 此时就会打印出data2</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这样的一个看着像<code class=\"language-text\">callback hell</code>的调用，就可以让我们的generator函数把异步安排的明明白白。</p>\n<h2 id=\"实现\"><a href=\"#%E5%AE%9E%E7%8E%B0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现</h2>\n<p>有了这样的思路，实现这个高阶函数就变得很简单了。</p>\n<p>先整体看一下结构，有个印象，然后我们逐行注释讲解。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">asyncToGenerator</span><span class=\"token punctuation\">(</span>generatorFunc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> gen <span class=\"token operator\">=</span> generatorFunc<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">function</span> <span class=\"token function\">step</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">let</span> generatorResult\n          <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            generatorResult <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">,</span> done <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> generatorResult\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>val <span class=\"token operator\">=></span> <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token string\">'next'</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> err <span class=\"token operator\">=></span> <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token string\">'throw'</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"next\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>不多不少，22行。  </p>\n<p>接下来逐行讲解。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">asyncToGenerator</span><span class=\"token punctuation\">(</span>generatorFunc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 返回的是一个新的函数</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  \n    <span class=\"token comment\">// 先调用generator函数 生成迭代器</span>\n    <span class=\"token comment\">// 对应 var gen = testG()</span>\n    <span class=\"token keyword\">const</span> gen <span class=\"token operator\">=</span> generatorFunc<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的</span>\n    <span class=\"token comment\">// var test = asyncToGenerator(testG)</span>\n    <span class=\"token comment\">// test().then(res => console.log(res))</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    \n      <span class=\"token comment\">// 内部定义一个step函数 用来一步一步的跨过yield的阻碍</span>\n      <span class=\"token comment\">// key有next和throw两种取值，分别对应了gen的next和throw方法</span>\n      <span class=\"token comment\">// arg参数则是用来把promise resolve出来的值交给下一个yield</span>\n      <span class=\"token keyword\">function</span> <span class=\"token function\">step</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> generatorResult\n        \n        <span class=\"token comment\">// 这个方法需要包裹在try catch中</span>\n        <span class=\"token comment\">// 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n          generatorResult <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// gen.next() 得到的结果是一个 { value, done } 的结构</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">,</span> done <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> generatorResult\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 如果已经完成了 就直接resolve这个promise</span>\n          <span class=\"token comment\">// 这个done是在最后一次调用next后才会为true</span>\n          <span class=\"token comment\">// 以本文的例子来说 此时的结果是 { done: true, value: 'success' }</span>\n          <span class=\"token comment\">// 这个value也就是generator函数最后的返回值</span>\n          <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 除了最后结束的时候外，每次调用gen.next()</span>\n          <span class=\"token comment\">// 其实是返回 { value: Promise, done: false } 的结构，</span>\n          <span class=\"token comment\">// 这里要注意的是Promise.resolve可以接受一个promise为参数</span>\n          <span class=\"token comment\">// 并且这个promise参数被resolve的时候，这个then才会被调用</span>\n          <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>\n            <span class=\"token comment\">// 这个value对应的是yield后面的promise</span>\n            value\n          <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>\n            <span class=\"token comment\">// value这个promise被resove的时候，就会执行next</span>\n            <span class=\"token comment\">// 并且只要done不是true的时候 就会递归的往下解开promise</span>\n            <span class=\"token comment\">// 对应gen.next().value.then(value => {</span>\n            <span class=\"token comment\">//    gen.next(value).value.then(value2 => {</span>\n            <span class=\"token comment\">//       gen.next() </span>\n            <span class=\"token comment\">//</span>\n            <span class=\"token comment\">//      // 此时done为true了 整个promise被resolve了 </span>\n            <span class=\"token comment\">//      // 最外部的test().then(res => console.log(res))的then就开始执行了</span>\n            <span class=\"token comment\">//    })</span>\n            <span class=\"token comment\">// })</span>\n            <span class=\"token keyword\">function</span> <span class=\"token function\">onResolve</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"next\"</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token comment\">// 如果promise被reject了 就再次进入step函数</span>\n            <span class=\"token comment\">// 不同的是，这次的try catch中调用的是gen.throw(err)</span>\n            <span class=\"token comment\">// 那么自然就被catch到 然后把promise给reject掉啦</span>\n            <span class=\"token keyword\">function</span> <span class=\"token function\">onReject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"throw\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"next\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"源码地址\"><a href=\"#%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>源码地址</h2>\n<p>这个 <a href=\"https://github.com/sl1673495/javascript-codes/blob/master/async.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">js文件</a> 的代码可以直接放进浏览器里运行，欢迎调戏。  </p>\n<h2 id=\"总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p>本文用最简单的方式实现了asyncToGenerator这个函数，这是babel编译async函数的核心，当然在babel中，generator函数也被编译成了一个很原始的形式，本文我们直接以generator替代。  </p>\n<p>这也是实现promise串行的一个很棒的模式，如果本篇文章对你有帮助，点个赞就好啦。  </p>\n<h2 id=\"️感谢大家\"><a href=\"#%EF%B8%8F%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>❤️感谢大家</h2>\n<p>1.如果本文对你有帮助，就点个赞支持下吧，你的「赞」是我创作的动力。</p>\n<p>2.关注公众号「前端从进阶到入院」即可加我好友，我拉你进「前端进阶交流群」，大家一起共同交流和进步。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/6/28/172f8f7d642a6c86?w=910&#x26;h=436&#x26;f=png&#x26;s=250863\"></p>","timeToRead":6,"frontmatter":{"title":"手写async await的最简实现（20行）","date":"September 02, 2020","spoiler":""},"fields":{"slug":"/690877951/","langKey":"en"}}},"pageContext":{"slug":"/690877951/","previous":{"fields":{"slug":"/683389653/","langKey":"en","directoryName":"683389653"},"frontmatter":{"title":"Vue3 + TypeScript 实现递归菜单组件"}},"next":{"fields":{"slug":"/690877725/","langKey":"en","directoryName":"690877725"},"frontmatter":{"title":"最简实现Promise，支持异步链式调用（20行）"}},"translations":[],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}