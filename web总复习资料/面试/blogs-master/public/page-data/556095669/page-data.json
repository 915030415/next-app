{"componentChunkName":"component---src-templates-blog-post-js","path":"/556095669/","result":{"data":{"site":{"siteMetadata":{"title":"ssh的博客","author":"ssh"}},"markdownRemark":{"id":"d87eda7f-cf28-5779-807c-b2342bc13306","html":"<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>Vue中的computed是一个非常强大的功能，在computed函数中访问到的值改变了后，computed的值也会自动改变。</p>\n<p>Vue2中的实现是利用了<code class=\"language-text\">Watcher</code>的嵌套收集，<code class=\"language-text\">渲染watcher</code>收集到<code class=\"language-text\">computed watcher</code>作为依赖，<code class=\"language-text\">computed watcher</code>又收集到<code class=\"language-text\">响应式数据某个属性</code>作为依赖，这样在<code class=\"language-text\">响应式数据某个属性</code>发生改变时，就会按照 <code class=\"language-text\">响应式属性</code> -> <code class=\"language-text\">computed值更新</code> -> <code class=\"language-text\">视图渲染</code>这样的触发链触发过去，如果对Vue2中的原理感兴趣，可以看我这篇文章的解析：  </p>\n<p><a href=\"https://juejin.im/post/5db6433b51882564912fc30f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">手把手带你实现一个最精简的响应式系统来学习Vue的data、computed、watch源码</a></p>\n<h2 id=\"前置知识\"><a href=\"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前置知识</h2>\n<p>阅读本文需要你先学习Vue3响应式的基本原理，可以先看我的这篇文章，原理和Vue3是一致的：\n<a href=\"https://juejin.im/post/5e21196fe51d454d523be084\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">带你彻底搞懂Vue3的Proxy响应式原理！TypeScript从零实现基于Proxy的响应式库。</a>  </p>\n<p>在你拥有了一些前置知识以后，默认你应该知道的是：  </p>\n<ol>\n<li><code class=\"language-text\">effect</code>其实就是一个依赖收集函数，在它内部访问了响应式数据，响应式数据就会把这个<code class=\"language-text\">effect</code>函数作为依赖收集起来，下次响应式数据改了就触发它重新执行。  </li>\n<li><code class=\"language-text\">reactive</code>返回的就是个响应式数据，这玩意可以和<code class=\"language-text\">effect</code>搭配使用。  </li>\n</ol>\n<p>举个简单的栗子吧：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 响应式数据</span>\n<span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 依赖收集</span>\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 触发上面的effect重新执行</span>\ndata<span class=\"token punctuation\">.</span>count <span class=\"token operator\">++</span></code></pre></div>\n<p>就这个例子来说，data是一个响应式数据。  </p>\n<p>effect传入的函数因为内部访问到它上面的属性<code class=\"language-text\">count</code>了，  </p>\n<p>所以形成了一个<code class=\"language-text\">count -&gt; effect</code>的依赖。</p>\n<p>下次count改变了，这个effect就会重新执行，就这么简单。  </p>\n<h2 id=\"computed\"><a href=\"#computed\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>computed</h2>\n<p>那么引入本文中的核心概念，<code class=\"language-text\">computed</code>来改写这个例子后呢：  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 1. 响应式数据</span>\n<span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 2. 计算属性</span>\n<span class=\"token keyword\">const</span> plusOne <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> data<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 3. 依赖收集</span>\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>plusOne<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 4. 触发上面的effect重新执行</span>\ndata<span class=\"token punctuation\">.</span>count <span class=\"token operator\">++</span></code></pre></div>\n<p>这样的例子也能跑通，为什么<code class=\"language-text\">data.count</code>的改变能<strong>间接触发</strong>访问了计算属性的effect的重新执行呢？</p>\n<p>我们来配合单点调试一步步解析。  </p>\n<h3 id=\"简化版源码\"><a href=\"#%E7%AE%80%E5%8C%96%E7%89%88%E6%BA%90%E7%A0%81\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>简化版源码</h3>\n<p>首先看一下简化版的<code class=\"language-text\">computed</code>的代码：  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span>\n  getter\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token keyword\">let</span> value<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span>\n\n  <span class=\"token comment\">// 这里还是利用了effect做依赖收集</span>\n  <span class=\"token keyword\">const</span> runner <span class=\"token operator\">=</span> <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 这里保证初始化的时候不去执行getter</span>\n    lazy<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    computed<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    scheduler<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 在触发更新时 只是把dirty置为true </span>\n      <span class=\"token comment\">// 而不去立刻计算值 所以计算属性有lazy的特性</span>\n      dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dirty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 在真正的去获取计算属性的value的时候</span>\n        <span class=\"token comment\">// 依据dirty的值决定去不去重新执行getter 获取最新值</span>\n        value <span class=\"token operator\">=</span> <span class=\"token function\">runner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 这里是关键 后续讲解</span>\n      <span class=\"token function\">trackChildRun</span><span class=\"token punctuation\">(</span>runner<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> value\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">set</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setter</span><span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看到，computed其实也是一个<code class=\"language-text\">effect</code>。这里对闭包进行了巧妙的运用，注释里的几个关键点决定了计算属性拥有<code class=\"language-text\">懒加载</code>的特征，你不去读取value的时候，它是不会去真正的求值的。  </p>\n<h3 id=\"前置准备\"><a href=\"#%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前置准备</h3>\n<p>首先要知道，effect函数会立即开始执行，再执行之前，先把<code class=\"language-text\">effect自身</code>变成全局的<code class=\"language-text\">activeEffect</code>，以供响应式数据收集依赖。  </p>\n<p>并且<code class=\"language-text\">activeEffect</code>的记录是用栈的方式，随着函数的开始执行入栈，随着函数的执行结束出栈，这样就可以维护嵌套的effect关系。  </p>\n<p>先起几个别名便于讲解</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 计算effect</span>\n<span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> data<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 日志effect</span>\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>plusOne<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>从依赖关系来看，<br>\n<code class=\"language-text\">日志effect</code>读取了<code class=\"language-text\">计算effect</code><br>\n<code class=\"language-text\">计算effect</code>读取了响应式属性<code class=\"language-text\">count</code><br>\n所以更新的顺序也应该是：<br>\n<code class=\"language-text\">count改变</code> -> <code class=\"language-text\">计算effect更新</code> -> <code class=\"language-text\">日志effect更新</code>  </p>\n<p>那么这个关系链是如何形成的呢  </p>\n<h3 id=\"单步解读\"><a href=\"#%E5%8D%95%E6%AD%A5%E8%A7%A3%E8%AF%BB\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>单步解读</h3>\n<p>在日志effect开始执行的时候，  </p>\n<p>⭐⭐<br>\n<strong>此时activeEffect是日志effect</strong>  </p>\n<p><strong>此时的effectStack是[ 日志effect ]</strong><br>\n⭐⭐  </p>\n<p>plusOne.value的读取，触发了</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"> <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dirty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 在真正的去获取计算属性的value的时候</span>\n        <span class=\"token comment\">// 依据dirty的值决定去不去重新执行getter 获取最新值</span>\n        value <span class=\"token operator\">=</span> <span class=\"token function\">runner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 这里是关键 后续讲解</span>\n      <span class=\"token function\">trackChildRun</span><span class=\"token punctuation\">(</span>runner<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> value\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p><code class=\"language-text\">runner</code>就是<code class=\"language-text\">计算effect</code>，进入了runner以后<br>\n⭐⭐<br>\n<strong>此时activeEffect是计算effect</strong>  </p>\n<p><strong>此时的effectStack是[ 日志effect, 计算effect ]</strong><br>\n⭐⭐<br>\n<code class=\"language-text\">computed(() =&gt; data.count + 1)</code>日志effect会去读取<code class=\"language-text\">count</code>，触发了响应式数据的<code class=\"language-text\">get</code>拦截：  </p>\n<p>此时<code class=\"language-text\">count</code>会收集<code class=\"language-text\">计算effect</code>作为自己的依赖。  </p>\n<p>并且<code class=\"language-text\">计算effect</code>会收集<code class=\"language-text\">count</code>的依赖集合，保存在自己身上。(通过<code class=\"language-text\">effect.deps</code>属性)  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">dep<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>activeEffect<span class=\"token punctuation\">)</span>\nactiveEffect<span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span></code></pre></div>\n<p>也就是形成了一个<strong>双向收集</strong>的关系，  </p>\n<p><code class=\"language-text\">计算effect</code>存了<code class=\"language-text\">count</code>的所有依赖，<code class=\"language-text\">count</code>也存了<code class=\"language-text\">计算effect</code>的依赖。  </p>\n<p>然后在runner运行结束后，<code class=\"language-text\">计算effect</code>出栈了，此时<code class=\"language-text\">activeEffect</code>变成了栈顶的<code class=\"language-text\">日志effect</code>  </p>\n<p>⭐⭐<br>\n<strong>此时activeEffect是日志effect</strong>  </p>\n<p><strong>此时的effectStack是[ 日志effect ]</strong><br>\n⭐⭐    </p>\n<p>接下来进入<strong>关键的步骤</strong>：<code class=\"language-text\">trackChildRun</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">trackChildRun</span><span class=\"token punctuation\">(</span>runner<span class=\"token punctuation\">)</span>  \n\n<span class=\"token keyword\">function</span> <span class=\"token function\">trackChildRun</span><span class=\"token punctuation\">(</span>childRunner<span class=\"token punctuation\">:</span> ReactiveEffect<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> childRunner<span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> dep <span class=\"token operator\">=</span> childRunner<span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    dep<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>activeEffect<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个<code class=\"language-text\">runner</code>就是<code class=\"language-text\">计算effect</code>，它的<code class=\"language-text\">deps</code>上此时挂着<code class=\"language-text\">count</code>的依赖集合，  </p>\n<p>在<code class=\"language-text\">trackChildRun</code>中，它把当前的acctiveEffect也就是<code class=\"language-text\">日志effect</code>也加入到了<code class=\"language-text\">count</code>的依赖集合中。  </p>\n<p>此时<code class=\"language-text\">count</code>的依赖集合是这样的：<code class=\"language-text\">[ 计算effect, 日志effect ]</code></p>\n<p>这样下次<code class=\"language-text\">count</code>更新的时候，会把两个effect都重新触发，而由于触发的顺序是先触发<code class=\"language-text\">computed effect</code> 后触发<code class=\"language-text\">普通effect</code>，因此就完成了</p>\n<ol>\n<li>计算effect的dirty置为true，标志着下次读取需要重新求值。</li>\n<li>日志effect读取计算effect的value，获得最新的值并打印出来。  </li>\n</ol>\n<h2 id=\"总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p>不得不承认，computed这个强大功能的实现果然少不了内部非常复杂的实现，这个双向依赖收集的套路相信也会给各位小伙伴带来很大的启发。跟着尤大学习，果然有肉吃！  </p>\n<p>另外由于<code class=\"language-text\">@vue/reactivity</code>的框架无关性，我把它整合进了React，做了一个状态管理库，可以完整的使用上述的<code class=\"language-text\">computed</code>等强大的Vue3能力。  </p>\n<p><a href=\"https://github.com/sl1673495/react-composition-api\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react-composition-api</a>  </p>\n<p>有兴趣的小伙伴也可以看一下，star一下！</p>","timeToRead":6,"frontmatter":{"title":"深度解析：Vue3如何巧妙的实现强大的computed","date":"January 28, 2020","spoiler":""},"fields":{"slug":"/556095669/","langKey":"en"}}},"pageContext":{"slug":"/556095669/","previous":{"fields":{"slug":"/551875543/","langKey":"en","directoryName":"551875543"},"frontmatter":{"title":"TypeScript从零实现基于Proxy的响应式库 基于函数劫持实现Map和Set的响应式"}},"next":{"fields":{"slug":"/557329151/","langKey":"en","directoryName":"557329151"},"frontmatter":{"title":"在React中引入Vue3的reactivity分包来实现最强大的状态管理。"}},"translations":[],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}