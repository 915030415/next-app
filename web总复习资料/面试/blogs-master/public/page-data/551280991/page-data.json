{"componentChunkName":"component---src-templates-blog-post-js","path":"/551280991/","result":{"data":{"site":{"siteMetadata":{"title":"ssh的博客","author":"ssh"}},"markdownRemark":{"id":"56fda435-e468-552d-9261-794e8f0b1eb3","html":"<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>笔者最近在浏览React状态管理库的时候，发现了一些响应式的状态管理库如\n<code class=\"language-text\">hodux</code>,<code class=\"language-text\">react-easy-state</code>，内部有一个基于proxy实现响应式的基础仓库<code class=\"language-text\">observer-util</code>，它的代码实现和Vue3中的响应式原理非常相似，这篇文章就从这个仓库入手，一步一步带你剖析响应式的实现。  </p>\n<p>本文的代码是我参考<code class=\"language-text\">observer-util</code>用ts的重写的，并且会加上非常详细的注释。  </p>\n<p>阅读本文可能需要的一些前置知识：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Proxy</a><br>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WeakMap</a><br>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Reflect</a>  </p>\n<p>首先看一下<code class=\"language-text\">observer-util</code>给出的代码示例：  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> observable<span class=\"token punctuation\">,</span> observe <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@nx-js/observer-util'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> counter <span class=\"token operator\">=</span> <span class=\"token function\">observable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> num<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 会在控制台打印出0</span>\n<span class=\"token keyword\">const</span> countLogger <span class=\"token operator\">=</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 会在控制台打印出1</span>\ncounter<span class=\"token punctuation\">.</span>num<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这就是一个最精简的响应式模型了，乍一看好像和Vue2里的响应式系统也没啥区别，那么还是先看一下Vue2和Vue3响应式系统之间的差异吧。  </p>\n<h2 id=\"和vue2的差异\"><a href=\"#%E5%92%8Cvue2%E7%9A%84%E5%B7%AE%E5%BC%82\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>和Vue2的差异</h2>\n<p>关于Vue2的响应式原理，感兴趣的也可以去看我之前的一篇文章：<br>\n<a href=\"https://juejin.im/post/5db6433b51882564912fc30f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">实现一个最精简的响应式系统来学习Vue的data、computed、watch源码</a>  </p>\n<p>其实这个问题本质上就是基于Proxy和基于Object.defineProperty之间的差异，来看Vue2中的一个案例：  </p>\n<h3 id=\"objectdefineproperty\"><a href=\"#objectdefineproperty\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.defineProperty</h3>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span><span class=\"token punctuation\">></span></span>\n  {{ obj.c }}\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n   <span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n       data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n           obj<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n       <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n       <span class=\"token function\">mounted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>obj<span class=\"token punctuation\">.</span>c <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n       <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>这个例子中，我们对obj上原本不存在的<code class=\"language-text\">c</code>属性进行了一个赋值，但是在Vue2中，这是不会触发响应式的。  </p>\n<p>这是因为Object.defineProperty必须对于确定的<code class=\"language-text\">key</code>值进行响应式的定义，  </p>\n<p>这就导致了如果data在初始化的时候没有<code class=\"language-text\">c</code>属性，那么后续对于<code class=\"language-text\">c</code>属性的赋值都不会触发Object.defineProperty中的劫持。  </p>\n<p>在Vue2中，这里只能用一个额外的api <code class=\"language-text\">Vue.set</code>来解决。    </p>\n<h3 id=\"proxy\"><a href=\"#proxy\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proxy</h3>\n<p>再看一下<code class=\"language-text\">Proxy</code>的api，</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> raw <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>可以看出来，Proxy在定义的时候并不用关心key值，  </p>\n<p>只要你定义了get方法，那么后续对于data上任何属性的访问（哪怕是不存在的），  </p>\n<p>都会触发<code class=\"language-text\">get</code>的劫持，<code class=\"language-text\">set</code>也是同理。  </p>\n<p>这样Vue3中，对于需要定义响应式的值，初始化时候的要求就没那么高了，只要保证它是个可以被Proxy接受的对象或者数组类型即可。  </p>\n<p>当然，Proxy对于数据拦截带来的便利还不止于此，往下看就知道。  </p>\n<h2 id=\"实现\"><a href=\"#%E5%AE%9E%E7%8E%B0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现</h2>\n<p>接下来就一步步实现这个基于Proxy的响应式系统：  </p>\n<h3 id=\"类型描述\"><a href=\"#%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>类型描述</h3>\n<p>本仓库基于TypeScript重构，所以会有一个类型定义的文件，可以当做接口先大致看一下  </p>\n<p><a href=\"https://github.com/sl1673495/typescript-proxy-reactive/blob/master/types/index.ts\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/sl1673495/typescript-proxy-reactive/blob/master/types/index.ts</a>  </p>\n<h3 id=\"思路\"><a href=\"#%E6%80%9D%E8%B7%AF\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>思路</h3>\n<p>首先响应式的思路无外乎这样一个模型：  </p>\n<ol>\n<li>定义某个数据为<code class=\"language-text\">响应式数据</code>，它会拥有收集<code class=\"language-text\">访问它的函数</code>的能力。</li>\n<li>定义观察函数，在这个函数内部去访问<code class=\"language-text\">响应式数据</code>。</li>\n</ol>\n<p>以开头的例子来说</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 响应式数据</span>\n<span class=\"token keyword\">const</span> counter <span class=\"token operator\">=</span> <span class=\"token function\">observable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> num<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 观察函数</span>\n<span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这已经一目了然了，</p>\n<ul>\n<li>用<code class=\"language-text\">observable</code>包裹的数据叫做响应式数据，</li>\n<li>在<code class=\"language-text\">observe</code>内部执行的函数叫<code class=\"language-text\">观察函数</code>。  </li>\n</ul>\n<p>观察函数首先开启某个开关，  </p>\n<h4 id=\"访问时\"><a href=\"#%E8%AE%BF%E9%97%AE%E6%97%B6\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>访问时</h4>\n<p>observe函数会帮你去执行<code class=\"language-text\">console.log(counter.num)</code>，  </p>\n<p>这时候<code class=\"language-text\">proxy</code>的<code class=\"language-text\">get</code>拦截到了对于<code class=\"language-text\">counter.num</code>的访问，  </p>\n<p>这时候又可以知道访问者是<code class=\"language-text\">() =&gt;  console.log(counter.num)</code>这个函数，  </p>\n<p>那么就把这个函数作为<code class=\"language-text\">num</code>这个key值的<code class=\"language-text\">观察函数</code>收集在一个地方。  </p>\n<h4 id=\"修改时\"><a href=\"#%E4%BF%AE%E6%94%B9%E6%97%B6\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>修改时</h4>\n<p>下次对于<code class=\"language-text\">counter.num</code>修改的时候，去找<code class=\"language-text\">num</code>这个key下所有的<code class=\"language-text\">观察函数</code>，轮流执行一遍。  </p>\n<p>这样就实现了响应式模型。  </p>\n<h2 id=\"reactive的实现（定义响应式数据）\"><a href=\"#reactive%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%AE%9A%E4%B9%89%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>reactive的实现（定义响应式数据）</h2>\n<p>上文中关于<code class=\"language-text\">observable</code>的api，我换了个名字: <code class=\"language-text\">reactive</code>，感觉更好理解一些。  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 需要定义响应式的原值</span>\n<span class=\"token keyword\">export</span> type Raw <span class=\"token operator\">=</span> object\n<span class=\"token comment\">// 定义成响应式后的proxy</span>\n<span class=\"token keyword\">export</span> type ReactiveProxy <span class=\"token operator\">=</span> object\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> proxyToRaw <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakMap</span><span class=\"token operator\">&lt;</span>ReactiveProxy<span class=\"token punctuation\">,</span> Raw<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> rawToProxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakMap</span><span class=\"token operator\">&lt;</span>Raw<span class=\"token punctuation\">,</span> ReactiveProxy<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> createReactive<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Raw</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> reactive <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">,</span> baseHandlers<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 双向存储原始值和响应式proxy的映射</span>\n  rawToProxy<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">,</span> reactive<span class=\"token punctuation\">)</span>\n  proxyToRaw<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>reactive<span class=\"token punctuation\">,</span> raw<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 建立一个映射</span>\n  <span class=\"token comment\">// 原始值 -> 存储这个原始值的各个key收集到的依赖函数的Map</span>\n  <span class=\"token function\">storeObservable</span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 返回响应式proxy</span>\n  <span class=\"token keyword\">return</span> reactive <span class=\"token keyword\">as</span> <span class=\"token constant\">T</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>首先是定义proxy</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> reactive <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">,</span> baseHandlers<span class=\"token punctuation\">)</span></code></pre></div>\n<p>这个baseHandlers里就是对于数据的<code class=\"language-text\">get</code>、<code class=\"language-text\">set</code>之类的劫持，</p>\n<p>这里有两个WeakMap： <code class=\"language-text\">proxyToRaw</code>和<code class=\"language-text\">rawToProxy</code>，  </p>\n<p>可以看到在定义响应式数据为一个Proxy的时候，会进行一个双向的存储，  </p>\n<p>这样后续无论是拿到原始对象还是拿到响应式proxy，都可以很容易的拿到它们的<code class=\"language-text\">另一半</code>。</p>\n<p>之后<code class=\"language-text\">storeObservable</code>，是用原始对象建立一个map：  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> connectionStore <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakMap</span><span class=\"token operator\">&lt;</span>Raw<span class=\"token punctuation\">,</span> ReactionForRaw<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">storeObservable</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">:</span> object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 存储对象和它内部的key -> reaction的映射</span>\n  connectionStore<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> ReactionForRaw<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>通过connectionStore的泛型也可以知道，  </p>\n<p>这是一个<code class=\"language-text\">Raw</code> -> <code class=\"language-text\">ReactionForRaw</code>的map。  </p>\n<p>也就是<code class=\"language-text\">原始数据</code> -> <code class=\"language-text\">这个数据收集到的观察函数依赖</code>  </p>\n<p>更清晰的描述可以看Type定义：  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 收集响应依赖的的函数</span>\n<span class=\"token keyword\">export</span> type <span class=\"token function-variable function\">ReactionFunction</span> <span class=\"token operator\">=</span> Function <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">{</span>\n  cleaners<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> ReactionForKey<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  unobserved<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// reactionForRaw的key为对象key值 value为这个key值收集到的Reaction集合</span>\n<span class=\"token keyword\">export</span> type ReactionForRaw <span class=\"token operator\">=</span> Map<span class=\"token operator\">&lt;</span>Key<span class=\"token punctuation\">,</span> ReactionForKey<span class=\"token operator\">></span>\n\n<span class=\"token comment\">// key值收集到的Reaction集合</span>\n<span class=\"token keyword\">export</span> type ReactionForKey <span class=\"token operator\">=</span> Set<span class=\"token operator\">&lt;</span>ReactionFunction<span class=\"token operator\">></span>\n\n<span class=\"token comment\">// 收集响应依赖的的函数</span>\n<span class=\"token keyword\">export</span> type <span class=\"token function-variable function\">ReactionFunction</span> <span class=\"token operator\">=</span> Function <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">{</span>\n  cleaners<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> ReactionForKey<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  unobserved<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那接下来的重点就是proxy的第二个参数<code class=\"language-text\">baseHandler</code>里的<code class=\"language-text\">get</code>和<code class=\"language-text\">set</code>了  </p>\n<h2 id=\"proxy的get\"><a href=\"#proxy%E7%9A%84get\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>proxy的get</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/** 劫持get访问 收集依赖 */</span>\n<span class=\"token keyword\">function</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">:</span> Raw<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> Key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">:</span> ReactiveProxy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span>\n  \n  <span class=\"token comment\">// 收集依赖</span>\n  <span class=\"token function\">registerRunningReaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">\"get\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> result\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>关于receiver这个参数，这里可以先简单理解为<code class=\"language-text\">响应式proxy</code>本身，不影响流程。  </p>\n<p>这里就是简单的做了一个求值，然后进入了<code class=\"language-text\">registerRunningReaction</code>函数，  </p>\n<h3 id=\"注册依赖\"><a href=\"#%E6%B3%A8%E5%86%8C%E4%BE%9D%E8%B5%96\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>注册依赖</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 收集响应依赖的的函数</span>\ntype <span class=\"token function-variable function\">ReactionFunction</span> <span class=\"token operator\">=</span> Function <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">{</span>\n  cleaners<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> ReactionForKey<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  unobserved<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 操作符 用来做依赖收集和触发依赖更新</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Operation</span> <span class=\"token punctuation\">{</span>\n  type<span class=\"token punctuation\">:</span> <span class=\"token string\">\"get\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"iterate\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"add\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"set\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"delete\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"clear\"</span>\n  target<span class=\"token punctuation\">:</span> object\n  key<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Key\n  receiver<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> any\n  value<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> any\n  oldValue<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> any\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/** 依赖收集栈 */</span>\n<span class=\"token keyword\">const</span> reactionStack<span class=\"token punctuation\">:</span> ReactionFunction<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">/** 依赖收集 在get操作的时候要调用 */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">registerRunningReaction</span><span class=\"token punctuation\">(</span>operation<span class=\"token punctuation\">:</span> Operation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> runningReaction <span class=\"token operator\">=</span> <span class=\"token function\">getRunningReaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>runningReaction<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 拿到原始对象 -> 观察者的map</span>\n      <span class=\"token keyword\">const</span> reactionsForRaw <span class=\"token operator\">=</span> connectionStore<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">// 拿到key -> 观察者的set</span>\n      <span class=\"token keyword\">let</span> reactionsForKey <span class=\"token operator\">=</span> reactionsForRaw<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    \n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>reactionsForKey<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 如果这个key之前没有收集过观察函数 就新建一个</span>\n        reactionsForKey <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// set到整个value的存储里去</span>\n        reactionsForRaw<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> reactionsForKey<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    \n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>reactionsForKey<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>reaction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 把这个key对应的观察函数收集起来</span>\n        reactionsForKey<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>reaction<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// 把key收集的观察函数集合 加到cleaners队列中 便于后续取消观察</span>\n        reaction<span class=\"token punctuation\">.</span>cleaners<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>reactionsForKey<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/** 从栈的末尾取到正在运行的observe包裹的函数 */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getRunningReaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>runningReaction<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> reactionStack<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> runningReaction\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里做的一系列操作，就是把用<code class=\"language-text\">原始数据</code>从<code class=\"language-text\">connectionStore</code>里拿到依赖收集的map，然后在<code class=\"language-text\">reaction</code>观察函数把对于某个<code class=\"language-text\">key</code>访问的时候，把<code class=\"language-text\">reaction</code>观察函数本身增加到这个<code class=\"language-text\">key</code>的观察函数集合里。  </p>\n<p>那么这个<code class=\"language-text\">runningReaction</code>正在运行的观察函数是哪来的呢，剧透一下，当然是<code class=\"language-text\">observe</code>这个api内部开启观察模式后去做的。  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 此时 () => console.log(counter.num) 会被包装成reaction函数</span>\n<span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"set\"><a href=\"#set\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>set</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/** 劫持set访问 触发收集到的观察函数 */</span>\n<span class=\"token keyword\">function</span> <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">:</span> Raw<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> Key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">:</span> ReactiveProxy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 拿到旧值</span>\n  <span class=\"token keyword\">const</span> oldValue <span class=\"token operator\">=</span> target<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n  <span class=\"token comment\">// 设置新值</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span>\n  \n  <span class=\"token function\">queueReactionsForOperation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      target<span class=\"token punctuation\">,</span>\n      key<span class=\"token punctuation\">,</span>\n      value<span class=\"token punctuation\">,</span>\n      oldValue<span class=\"token punctuation\">,</span>\n      receiver<span class=\"token punctuation\">,</span>\n      type<span class=\"token punctuation\">:</span> <span class=\"token string\">'set'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> result\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/** 值更新时触发观察函数 */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">queueReactionsForOperation</span><span class=\"token punctuation\">(</span>operation<span class=\"token punctuation\">:</span> Operation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getReactionsForOperation</span><span class=\"token punctuation\">(</span>operation<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>reaction <span class=\"token operator\">=></span> <span class=\"token function\">reaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n *  根据key,type和原始对象 拿到需要触发的所有观察函数\n */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getReactionsForOperation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> type <span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span> Operation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 拿到原始对象 -> 观察者的map</span>\n  <span class=\"token keyword\">const</span> reactionsForTarget <span class=\"token operator\">=</span> connectionStore<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> reactionsForKey<span class=\"token punctuation\">:</span> ReactionForKey <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 把所有需要触发的观察函数都收集到新的set里</span>\n  <span class=\"token function\">addReactionsForKey</span><span class=\"token punctuation\">(</span>reactionsForKey<span class=\"token punctuation\">,</span> reactionsForTarget<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> reactionsForKey\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">set</code>赋值操作的时候，本质上就是去检查这个<code class=\"language-text\">key</code>收集到了哪些<code class=\"language-text\">reaction</code>观察函数，然后依次触发。  </p>\n<h2 id=\"observe-观察函数\"><a href=\"#observe-%E8%A7%82%E5%AF%9F%E5%87%BD%E6%95%B0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>observe 观察函数</h2>\n<p><code class=\"language-text\">observe</code>这个api接受一个用户传入的函数，在这个函数内访问响应式数据才会去收集观察函数作为自己的依赖。  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/** \n * 观察函数\n * 在传入的函数里去访问响应式的proxy 会收集传入的函数作为依赖\n * 下次访问的key发生变化的时候 就会重新运行这个函数\n */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> ReactionFunction <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// reaction是包装了原始函数只后的观察函数</span>\n  <span class=\"token comment\">// 在runReactionWrap的上下文中执行原始函数 可以收集到依赖。</span>\n  <span class=\"token keyword\">const</span> reaction<span class=\"token punctuation\">:</span> <span class=\"token function-variable function\">ReactionFunction</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">runReactionWrap</span><span class=\"token punctuation\">(</span>reaction<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 先执行一遍reaction</span>\n  <span class=\"token function\">reaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 返回出去 让外部也可以手动调用</span>\n  <span class=\"token keyword\">return</span> reaction\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>核心的逻辑在<code class=\"language-text\">runReactionWrap</code>里，</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/** 把函数包裹为观察函数 */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">runReactionWrap</span><span class=\"token punctuation\">(</span>\n  reaction<span class=\"token punctuation\">:</span> ReactionFunction<span class=\"token punctuation\">,</span>\n  fn<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span>\n  context<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n  args<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 把当前的观察函数推入栈内 开始观察响应式proxy</span>\n    reactionStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>reaction<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 运行用户传入的函数 这个函数里访问proxy就会收集reaction函数作为依赖了</span>\n    <span class=\"token keyword\">return</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 运行完了永远要出栈</span>\n    reactionStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>简化后的核心逻辑很简单，  </p>\n<p>把<code class=\"language-text\">reaction</code>推入<code class=\"language-text\">reactionStack</code>后开始执行用户传入的函数，  </p>\n<p>在函数内访问<code class=\"language-text\">响应式proxy</code>的属性，又会触发<code class=\"language-text\">get</code>的拦截，  </p>\n<p>这时候<code class=\"language-text\">get</code>去<code class=\"language-text\">reactionStack</code>找当前正在运行的<code class=\"language-text\">reaction</code>，就可以成功的收集到依赖了。  </p>\n<p>下一次用户进行赋值的时候</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> counter <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> num<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 会在控制台打印出0</span>\n<span class=\"token keyword\">const</span> counterReaction <span class=\"token operator\">=</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 会在控制台打印出1</span>\ncounter<span class=\"token punctuation\">.</span>num <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>以这个示例来说，observe内部对于counter的key值<code class=\"language-text\">num的</code>访问，会收集<code class=\"language-text\">counterReaction</code>作为<code class=\"language-text\">num</code>的依赖。  </p>\n<p><code class=\"language-text\">counter.num = 1</code>的操作，会触发对于counter的<code class=\"language-text\">set</code>劫持，此时就会从<code class=\"language-text\">key</code>值的依赖收集里面找到<code class=\"language-text\">counterReaction</code>，再重新执行一遍。  </p>\n<h2 id=\"边界情况\"><a href=\"#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>边界情况</h2>\n<p>以上实现只是一个最基础的响应式模型，还没有实现的点有：</p>\n<ul>\n<li>深层数据的劫持</li>\n<li>数组和对象新增、删除项的响应</li>\n</ul>\n<p>接下来在上面的代码的基础上来实现这两种情况： </p>\n<h3 id=\"深层数据的劫持\"><a href=\"#%E6%B7%B1%E5%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%AB%E6%8C%81\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>深层数据的劫持</h3>\n<p>在刚刚的代码实现中，我们只对Proxy的第一层属性做了拦截，假设有这样的一个场景</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> counter <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> num<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 会在控制台打印出0</span>\n<span class=\"token keyword\">const</span> counterReaction <span class=\"token operator\">=</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ncounter<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>num <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这种场景就不能实能触发<code class=\"language-text\">counterReaction</code>自动执行了。  </p>\n<p>因为counter.data.num其实是对<code class=\"language-text\">data</code>上的<code class=\"language-text\">num</code>属性进行赋值，而counter虽然是一个<code class=\"language-text\">响应式proxy</code>，但<code class=\"language-text\">counter.data</code>却只是一个普通的对象，回想一下刚刚的proxy<code class=\"language-text\">get</code>的拦截函数：  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/** 劫持get访问 收集依赖 */</span>\n<span class=\"token keyword\">function</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">:</span> Raw<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> Key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">:</span> ReactiveProxy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span>\n  \n  <span class=\"token comment\">// 收集依赖</span>\n  <span class=\"token function\">registerRunningReaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">\"get\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> result\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">counter.data</code>只是通过Reflect.get拿到了原始的 { data: {number } }对象，然后对这个对象的赋值不会被proxy拦截到。  </p>\n<p>那么思路其实也有了，就是在深层访问的时候，如果访问的数据是个对象，就把这个对象也用<code class=\"language-text\">reactive</code>包装成proxy再返回，这样在进行<code class=\"language-text\">counter.data.num = 1;</code>赋值的时候，其实也是针对一个<code class=\"language-text\">响应式proxy</code>赋值了。  </p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">/** 劫持get访问 收集依赖 */\nfunction get(target: Raw, key: Key, receiver: ReactiveProxy) {\n  const result = Reflect.get(target, key, receiver)\n  // 收集依赖\n  registerRunningReaction({ target, key, receiver, type: \"get\" })\n\n<span class=\"token inserted\">+  // 如果访问的是对象 则返回这个对象的响应式proxy</span>\n<span class=\"token inserted\">+  if (isObject(result)) {</span>\n<span class=\"token inserted\">+    return reactive(result)</span>\n<span class=\"token inserted\">+  }</span>\n\n  return result\n}</code></pre></div>\n<h3 id=\"数组和对象新增、删除项的响应\"><a href=\"#%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E3%80%81%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9A%84%E5%93%8D%E5%BA%94\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>数组和对象新增、删除项的响应</h3>\n<p>以这样一个场景为例  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> data<span class=\"token punctuation\">:</span> any <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\ndata<span class=\"token punctuation\">.</span>c <span class=\"token operator\">=</span> <span class=\"token number\">5</span></code></pre></div>\n<p>其实在用Object.keys访问data的时候，后续不管是data上的key发生了新增或者删除，都应该触发这个观察函数，那么这是怎么实现的呢？  </p>\n<p>首先我们需要知道，Object.keys(data)访问proxy的时候，会触发proxy的<code class=\"language-text\">ownKeys</code>拦截。  </p>\n<p>那么我们在<code class=\"language-text\">baseHandler</code>中先新增对于<code class=\"language-text\">ownKeys</code>的访问拦截：</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">/** 劫持get访问 收集依赖 */\nfunction get() {}\n\n/** 劫持set访问 触发收集到的观察函数 */\nfunction set() {\n}\n\n/** 劫持一些遍历访问 比如Object.keys */\n<span class=\"token inserted\">+ function ownKeys (target: Raw) {</span>\n<span class=\"token inserted\">+   registerRunningReaction({ target, type: 'iterate' })</span>\n<span class=\"token inserted\">+   return Reflect.ownKeys(target)</span>\n<span class=\"token inserted\">+ }</span></code></pre></div>\n<p>还是和get方法一样，调用<code class=\"language-text\">registerRunningReaction</code>方法注册依赖，但是type我们需要定义成<code class=\"language-text\">iterate</code>，这个type怎么用呢。我们继续改造<code class=\"language-text\">registerRunningReaction</code>函数：  </p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\"><span class=\"token inserted\">+ const ITERATION_KEY = Symbol(\"iteration key\")</span>\n\nexport function registerRunningReaction(operation: Operation) {\n  const runningReaction = getRunningReaction()\n  if (runningReaction) {\n<span class=\"token inserted\">+      if (type === \"iterate\") {</span>\n<span class=\"token inserted\">+        key = ITERATION_KEY</span>\n<span class=\"token inserted\">+      }</span>\n      // 拿到原始对象 -> 观察者的map\n      const reactionsForRaw = connectionStore.get(target)\n      // 拿到key -> 观察者的set\n      let reactionsForKey = reactionsForRaw.get(key)\n    \n      if (!reactionsForKey) {\n        // 如果这个key之前没有收集过观察函数 就新建一个\n        reactionsForKey = new Set()\n        // set到整个value的存储里去\n        reactionsForRaw.set(key, reactionsForKey)\n      }\n    \n      if (!reactionsForKey.has(reaction)) {\n        // 把这个key对应的观察函数收集起来\n        reactionsForKey.add(reaction)\n        // 把key收集的观察函数集合 加到cleaners队列中 便于后续取消观察\n        reaction.cleaners.push(reactionsForKey)\n      }\n  }\n}</code></pre></div>\n<p>也就是<code class=\"language-text\">type: iterate</code>触发的依赖收集，我们会放在key为<code class=\"language-text\">ITERATION_KEY</code>的一个特殊的set里，那么再来看看触发更新时的<code class=\"language-text\">set</code>改造：  </p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">/** 劫持set访问 触发收集到的观察函数 */\nfunction set(target: Raw, key: Key, value: any, receiver: ReactiveProxy) {\n  // 拿到旧值\n  const oldValue = target[key]\n  // 设置新值\n  const result = Reflect.set(target, key, value, receiver)\n<span class=\"token inserted\">+  // 先检查一下这个key是不是新增的</span>\n<span class=\"token inserted\">+  const hadKey = hasOwnProperty.call(target, key)</span>\n\n<span class=\"token inserted\">+  if (!hadKey) {</span>\n<span class=\"token inserted\">+    // 新增key值时触发观察函数</span>\n<span class=\"token inserted\">+    queueReactionsForOperation({ target, key, value, receiver, type: 'add' })</span>\n  } else if (value !== oldValue) {\n    // 已存在的key的值发生变化时触发观察函数\n    queueReactionsForOperation({\n      target,\n      key,\n      value,\n      oldValue,\n      receiver,\n      type: 'set'\n    })\n  }\n\n  return result\n}</code></pre></div>\n<p>这里对新增的key也进行了的判断，传入<code class=\"language-text\">queueReactionsForOperation</code>的type变成了<code class=\"language-text\">add</code></p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">/** 值更新时触发观察函数 */\nexport function queueReactionsForOperation(operation: Operation) {\n  getReactionsForOperation(operation).forEach(reaction => reaction())\n}\n\n/**\n *  根据key,type和原始对象 拿到需要触发的所有观察函数\n */\nexport function getReactionsForOperation({ target, key, type }: Operation) {\n  // 拿到原始对象 -> 观察者的map\n  const reactionsForTarget = connectionStore.get(target)\n  const reactionsForKey: ReactionForKey = new Set()\n\n  // 把所有需要触发的观察函数都收集到新的set里\n  addReactionsForKey(reactionsForKey, reactionsForTarget, key)\n\n  // add和delete的操作 需要触发某些由循环触发的观察函数收集\n  // observer(() => rectiveProxy.forEach(() => proxy.foo))\n<span class=\"token inserted\">+  if (type === \"add\" || type === \"delete\") {</span>\n<span class=\"token inserted\">+    const iterationKey = Array.isArray(target) ? \"length\" : ITERATION_KEY</span>\n<span class=\"token inserted\">+    addReactionsForKey(reactionsForKey, reactionsForTarget, iterationKey)</span>\n  }\n  return reactionsForKey\n}</code></pre></div>\n<p>这里需要注意的是，对于数组新增和删除项来说，如果我们在观察函数中做了遍历操作，也需要触发它的更新，  </p>\n<p>这里又有一个知识点，对于数组遍历的操作，都会触发它对<code class=\"language-text\">length</code>的读取，然后把观察函数收集到<code class=\"language-text\">length</code>这个key的依赖中，比如</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> proxyArray<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 会访问proxyArray的length。</span></code></pre></div>\n<p>所以在触发更新的时候，</p>\n<ol>\n<li>如果目标是个数组，那就从<code class=\"language-text\">length</code>的依赖里收集，</li>\n<li>如果目标是对象，就从<code class=\"language-text\">ITERATION_KEY</code>的依赖里收集。（也就是对于对象做Object.keys读取时，由<code class=\"language-text\">ownKeys</code>拦截收集的依赖）。</li>\n</ol>\n<h2 id=\"源码地址\"><a href=\"#%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>源码地址</h2>\n<p><a href=\"https://github.com/sl1673495/typescript-proxy-reactive\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/sl1673495/typescript-proxy-reactive</a>  </p>\n<h2 id=\"总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p>由于篇幅原因，有一些优化的操作我没有在文中写出来，在仓库里做了几乎是逐行注释，而且也可以用<code class=\"language-text\">npm run dev</code>对example文件夹中的例子进行调试。感兴趣的同学可以自己看一下。  </p>\n<p>如果读完了还觉得有兴致，也可以直接去看<code class=\"language-text\">observe-util</code>这个库的源码，里面对于更多的边界情况做了处理，代码也写的非常优雅，值得学习。  </p>\n<p>从本文里讲解的一些边界情况也可以看出，基于Proxy的响应式方案比Object.defineProperty要强大很多，希望大家尽情的享受Vue3带来的快落吧。  </p>","timeToRead":16,"frontmatter":{"title":"TypeScript从零实现基于Proxy的响应式库 普通数据类型","date":"January 17, 2020","spoiler":""},"fields":{"slug":"/551280991/","langKey":"en"}}},"pageContext":{"slug":"/551280991/","previous":{"fields":{"slug":"/549412377/","langKey":"en","directoryName":"549412377"},"frontmatter":{"title":"TypeScript进阶实现智能类型推导的简化版Vuex"}},"next":{"fields":{"slug":"/551875543/","langKey":"en","directoryName":"551875543"},"frontmatter":{"title":"TypeScript从零实现基于Proxy的响应式库 基于函数劫持实现Map和Set的响应式"}},"translations":[],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}