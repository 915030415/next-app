{"componentChunkName":"component---src-templates-blog-post-js","path":"/593881324/","result":{"data":{"site":{"siteMetadata":{"title":"ssh的博客","author":"ssh"}},"markdownRemark":{"id":"0106086e-c282-531d-97b3-0b1747642b28","html":"<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>相信大家对 Vue 有哪些生命周期早就已经烂熟于心，但是对于这些生命周期的前后分别做了哪些事情，可能还有些不熟悉。</p>\n<p>本篇文章就从一个完整的流程开始，详细讲解各个生命周期之间发生了什么事情。</p>\n<p>注意本文不涉及 <code class=\"language-text\">keep-alive</code> 的场景和错误处理的场景。</p>\n<h2 id=\"初始化流程\"><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>初始化流程</h2>\n<h3 id=\"new-vue\"><a href=\"#new-vue\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>new Vue</h3>\n<p>从 <code class=\"language-text\">new Vue(options)</code> 开始作为入口，<code class=\"language-text\">Vue</code> 只是一个简单的构造函数，内部是这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Vue</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_init</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>进入了 <code class=\"language-text\">_init</code> 函数之后，先初始化了一些属性，然后开始第一个生命周期：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeCreate'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"beforecreate被调用完成\"><a href=\"#beforecreate%E8%A2%AB%E8%B0%83%E7%94%A8%E5%AE%8C%E6%88%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>beforeCreate被调用完成</h3>\n<p><code class=\"language-text\">beforeCreate</code> 之后</p>\n<ol>\n<li>初始化 <code class=\"language-text\">inject</code></li>\n<li>\n<p>初始化 <code class=\"language-text\">state</code></p>\n<ul>\n<li>初始化 <code class=\"language-text\">props</code></li>\n<li>初始化 <code class=\"language-text\">methods</code></li>\n<li>初始化 <code class=\"language-text\">data</code></li>\n<li>初始化 <code class=\"language-text\">computed</code></li>\n<li>初始化 <code class=\"language-text\">watch</code></li>\n</ul>\n</li>\n<li>初始化 <code class=\"language-text\">provide</code></li>\n</ol>\n<p>所以在 <code class=\"language-text\">data</code> 中可以使用 <code class=\"language-text\">props</code> 上的值，反过来则不行。</p>\n<p>然后进入 <code class=\"language-text\">created</code> 阶段：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'created'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"created被调用完成\"><a href=\"#created%E8%A2%AB%E8%B0%83%E7%94%A8%E5%AE%8C%E6%88%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>created被调用完成</h3>\n<p>调用 <code class=\"language-text\">$mount</code> 方法，开始挂载组件到 <code class=\"language-text\">dom</code> 上。</p>\n<p>如果使用了 <code class=\"language-text\">runtime-with-compile</code> 版本，则会把你传入的 <code class=\"language-text\">template</code> 选项，或者 <code class=\"language-text\">html</code> 文本，通过一系列的编译生成 <code class=\"language-text\">render</code> 函数。</p>\n<ul>\n<li>编译这个 <code class=\"language-text\">template</code>，生成 <code class=\"language-text\">ast</code> 抽象语法树。</li>\n<li>优化这个 <code class=\"language-text\">ast</code>，标记静态节点。（渲染过程中不会变的那些节点，优化性能）。</li>\n<li>根据 <code class=\"language-text\">ast</code>，生成 <code class=\"language-text\">render</code> 函数。</li>\n</ul>\n<p>对应具体的代码就是：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> ast <span class=\"token operator\">=</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>optimize <span class=\"token operator\">!==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">optimize</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> code <span class=\"token operator\">=</span> <span class=\"token function\">generate</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span></code></pre></div>\n<p>如果是脚手架搭建的项目的话，这一步 <code class=\"language-text\">vue-cli</code> 已经帮你做好了，所以就直接进入 <code class=\"language-text\">mountComponent</code> 函数。</p>\n<p>那么，确保有了 <code class=\"language-text\">render</code> 函数后，我们就可以往<code class=\"language-text\">渲染</code>的步骤继续进行了</p>\n<h3 id=\"beforemount被调用完成\"><a href=\"#beforemount%E8%A2%AB%E8%B0%83%E7%94%A8%E5%AE%8C%E6%88%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>beforeMount被调用完成</h3>\n<p>把 <code class=\"language-text\">渲染组件的函数</code> 定义好，具体代码是：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function-variable function\">updateComponent</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  vm<span class=\"token punctuation\">.</span><span class=\"token function\">_update</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span><span class=\"token function\">_render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>拆解来看，<code class=\"language-text\">vm._render</code> 其实就是调用我们上一步拿到的 <code class=\"language-text\">render</code> 函数生成一个 <code class=\"language-text\">vnode</code>，而 <code class=\"language-text\">vm._update</code> 方法则会对这个 <code class=\"language-text\">vnode</code> 进行 <code class=\"language-text\">patch</code> 操作，帮我们把 <code class=\"language-text\">vnode</code> 通过 <code class=\"language-text\">createElm</code>函数创建新节点并且渲染到 <code class=\"language-text\">dom节点</code> 中。</p>\n<p>接下来就是执行这段代码了，是由 <code class=\"language-text\">响应式原理</code> 的一个核心类 <code class=\"language-text\">Watcher</code> 负责执行这个函数，为什么要它来代理执行呢？因为我们需要在这段过程中去 <code class=\"language-text\">观察</code> 这个函数读取了哪些响应式数据，将来这些响应式数据更新的时候，我们需要重新执行 <code class=\"language-text\">updateComponent</code> 函数。</p>\n<p>如果是更新后调用 <code class=\"language-text\">updateComponent</code> 函数的话，<code class=\"language-text\">updateComponent</code> 内部的 <code class=\"language-text\">patch</code> 就不再是初始化时候的创建节点，而是对新旧 <code class=\"language-text\">vnode</code> 进行 <code class=\"language-text\">diff</code>，最小化的更新到 <code class=\"language-text\">dom节点</code> 上去。具体过程可以看我的上一篇文章：</p>\n<p><a href=\"https://juejin.im/post/5e8694b75188257372503722\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">为什么 Vue 中不要用 index 作为 key？（diff 算法详解）</a></p>\n<p>这一切交给 <code class=\"language-text\">Watcher</code> 完成：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Watcher</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> updateComponent<span class=\"token punctuation\">,</span> noop<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">before</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_isMounted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeUpdate'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">/* isRenderWatcher */</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>注意这里在<code class=\"language-text\">before</code> 属性上定义了<code class=\"language-text\">beforeUpdate</code> 函数，也就是说在 <code class=\"language-text\">Watcher</code> 被响应式属性的更新触发之后，重新渲染新视图之前，会先调用 <code class=\"language-text\">beforeUpdate</code> 生命周期。</p>\n<p>关于 <code class=\"language-text\">Watcher</code> 和响应式的概念，如果你还不清楚的话，可以阅读我之前的文章：</p>\n<p><a href=\"https://juejin.im/post/5db6433b51882564912fc30f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">手把手带你实现一个最精简的响应式系统来学习Vue的data、computed、watch源码</a></p>\n<p>注意，在 <code class=\"language-text\">render</code> 的过程中，如果遇到了 <code class=\"language-text\">子组件</code>，则会调用 <code class=\"language-text\">createComponent</code> 函数。</p>\n<p><code class=\"language-text\">createComponent</code> 函数内部，会为子组件生成一个属于自己的<code class=\"language-text\">构造函数</code>，可以理解为子组件自己的 <code class=\"language-text\">Vue</code> 函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">Ctor <span class=\"token operator\">=</span> baseCtor<span class=\"token punctuation\">.</span><span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>Ctor<span class=\"token punctuation\">)</span></code></pre></div>\n<p>在普通的场景下，其实这就是 <code class=\"language-text\">Vue.extend</code> 生成的构造函数，它继承自 <code class=\"language-text\">Vue</code> 函数，拥有它的很多全局属性。</p>\n<p>这里插播一个知识点，除了组件有自己的<code class=\"language-text\">生命周期</code>外，其实 <code class=\"language-text\">vnode</code> 也是有自己的 <code class=\"language-text\">生命周期的</code>，只不过我们平常开发的时候是接触不到的。</p>\n<p>那么<code class=\"language-text\">子组件的 vnode</code> 会有自己的 <code class=\"language-text\">init</code> 周期，这个周期内部会做这样的事情：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 创建子组件</span>\n<span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> <span class=\"token function\">createComponentInstanceForVnode</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 挂载到 dom 上</span>\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">$mount</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span></code></pre></div>\n<p>而 <code class=\"language-text\">createComponentInstanceForVnode</code> 内部又做了什么事呢？它会去调用 <code class=\"language-text\">子组件</code> 的构造函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">vnode<span class=\"token punctuation\">.</span>componentOptions<span class=\"token punctuation\">.</span>Ctor</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span></code></pre></div>\n<p>构造函数的内部是这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Sub</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">VueComponent</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_init</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个 <code class=\"language-text\">_init</code> 其实就是我们文章开头的那个函数，也就是说，如果遇到 <code class=\"language-text\">子组件</code>，那么就会优先开始<code class=\"language-text\">子组件</code>的构建过程，也就是说，从 <code class=\"language-text\">beforeCreated</code> 重新开始。这是一个递归的构建过程。</p>\n<p>也就是说，如果我们有 <code class=\"language-text\">父 -&gt; 子 -&gt; 孙</code> 这三个组件，那么它们的初始化生命周期顺序是这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">父 beforeCreate \n父 create \n父 beforeMount \n子 beforeCreate \n子 create \n子 beforeMount \n孙 beforeCreate \n孙 create \n孙 beforeMount \n孙 mounted \n子 mounted \n父 mounted </code></pre></div>\n<p>然后，<code class=\"language-text\">mounted</code> 生命周期被触发。</p>\n<h3 id=\"mounted被调用完成\"><a href=\"#mounted%E8%A2%AB%E8%B0%83%E7%94%A8%E5%AE%8C%E6%88%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>mounted被调用完成</h3>\n<p>到此为止，组件的挂载就完成了，初始化的生命周期结束。</p>\n<h2 id=\"更新流程\"><a href=\"#%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>更新流程</h2>\n<p>当一个响应式属性被更新后，触发了 <code class=\"language-text\">Watcher</code> 的回调函数，也就是 <code class=\"language-text\">vm._update(vm._render())</code>，在更新之前，会先调用刚才在 <code class=\"language-text\">before</code> 属性上定义的函数，也就是</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeUpdate'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>注意，由于 Vue 的异步更新机制，<code class=\"language-text\">beforeUpdate</code> 的调用已经是在 <code class=\"language-text\">nextTick</code> 中了。\n具体代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span>flushSchedulerQueue<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> flushSchedulerQueue <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    watcher <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>watcher<span class=\"token punctuation\">.</span>before<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\">// callHook(vm, 'beforeUpdate')</span>\n      watcher<span class=\"token punctuation\">.</span><span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"beforeupdate被调用完成\"><a href=\"#beforeupdate%E8%A2%AB%E8%B0%83%E7%94%A8%E5%AE%8C%E6%88%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>beforeUpdate被调用完成</h3>\n<p>然后经历了一系列的 <code class=\"language-text\">patch</code>、<code class=\"language-text\">diff</code> 流程后，组件重新渲染完毕，调用 <code class=\"language-text\">updated</code> 钩子。</p>\n<p>注意，这里是对 <code class=\"language-text\">watcher</code> 倒序 <code class=\"language-text\">updated</code> 调用的。</p>\n<p>也就是说，假如同一个属性通过 <code class=\"language-text\">props</code> 分别流向 <code class=\"language-text\">父 -&gt; 子 -&gt; 孙</code> 这个路径，那么收集到依赖的先后也是这个顺序，但是触发 <code class=\"language-text\">updated</code> 钩子确是 <code class=\"language-text\">孙 -&gt; 子 -&gt; 父</code> 这个顺序去触发的。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">callUpdatedHooks</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>length\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> watcher <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">const</span> vm <span class=\"token operator\">=</span> watcher<span class=\"token punctuation\">.</span>vm\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_watcher <span class=\"token operator\">===</span> watcher <span class=\"token operator\">&amp;&amp;</span> vm<span class=\"token punctuation\">.</span>_isMounted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'updated'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"updated被调用完成\"><a href=\"#updated%E8%A2%AB%E8%B0%83%E7%94%A8%E5%AE%8C%E6%88%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>updated被调用完成</h3>\n<p>至此，渲染更新流程完毕。</p>\n<h2 id=\"销毁流程\"><a href=\"#%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>销毁流程</h2>\n<p>在刚刚所说的更新后的 <code class=\"language-text\">patch</code> 过程中，如果发现有组件在下一轮渲染中消失了，比如 <code class=\"language-text\">v-for</code> 对应的数组中少了一个数据。那么就会调用 <code class=\"language-text\">removeVnodes</code> 进入组件的销毁流程。</p>\n<p><code class=\"language-text\">removeVnodes</code> 会调用 <code class=\"language-text\">vnode</code> 的 <code class=\"language-text\">destroy</code> 生命周期，而 <code class=\"language-text\">destroy</code> 内部则会调用我们相对比较熟悉的 <code class=\"language-text\">vm.$destroy()</code>。（keep-alive 包裹的子组件除外）</p>\n<p>这时，就会调用 <code class=\"language-text\">callHook(vm, &#39;beforeDestroy&#39;)</code></p>\n<h3 id=\"beforedestroy被调用完成\"><a href=\"#beforedestroy%E8%A2%AB%E8%B0%83%E7%94%A8%E5%AE%8C%E6%88%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>beforeDestroy被调用完成</h3>\n<p>之后就会经历一系列的<code class=\"language-text\">清理</code>逻辑，清除父子关系、<code class=\"language-text\">watcher</code> 关闭等逻辑。但是注意，<code class=\"language-text\">$destroy</code> 并不会把组件从视图上移除，如果想要手动销毁一个组件，则需要我们自己去完成这个逻辑。</p>\n<p>然后，调用最后的 <code class=\"language-text\">callHook(vm, &#39;destroyed&#39;)</code></p>\n<h3 id=\"destroyed被调用完成\"><a href=\"#destroyed%E8%A2%AB%E8%B0%83%E7%94%A8%E5%AE%8C%E6%88%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>destroyed被调用完成</h3>\n<h2 id=\"总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p>至此为止，Vue 的生命周期我们就完整的回顾了一遍。知道各个生命周期之间发生了什么事，可以让我们在编写 Vue 组件的过程中更加胸有成竹。</p>\n<p>希望这篇文章对你有帮助。</p>\n<h2 id=\"️感谢大家\"><a href=\"#%EF%B8%8F%E6%84%9F%E8%B0%A2%E5%A4%A7%E5%AE%B6\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>❤️感谢大家</h2>\n<p>1.如果本文对你有帮助，就点个赞支持下吧，你的「赞」是我创作的动力。</p>\n<p>2.关注公众号「前端从进阶到入院」即可加我好友，我拉你进「前端进阶交流群」，大家一起共同交流和进步。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/4/5/17146620730c6889?w=573&#x26;h=265&#x26;f=jpeg&#x26;s=54095\"></p>","timeToRead":8,"frontmatter":{"title":"Vue 的生命周期之间到底做了什么事清？（源码详解）","date":"April 04, 2020","spoiler":""},"fields":{"slug":"/593881324/","langKey":"en"}}},"pageContext":{"slug":"/593881324/","previous":{"fields":{"slug":"/592778801/","langKey":"en","directoryName":"592778801"},"frontmatter":{"title":"为什么 Vue 中不要用 index 作为 key？（diff 算法详解）"}},"next":{"fields":{"slug":"/595351553/","langKey":"en","directoryName":"595351553"},"frontmatter":{"title":"Vue 进阶必学之高阶组件实战"}},"translations":[],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}