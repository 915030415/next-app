{"componentChunkName":"component---src-templates-blog-post-js","path":"/591974262/","result":{"data":{"site":{"siteMetadata":{"title":"ssh的博客","author":"ssh"}},"markdownRemark":{"id":"37ac5958-b19e-567c-ba67-2d1fb6a1a663","html":"<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>我们都知道 Vue 对于响应式属性的更新，只会精确更新依赖收集的<code class=\"language-text\">当前组件</code>，而不会递归的去更新子组件，这也是它性能强大的原因之一。</p>\n<h2 id=\"例子\"><a href=\"#%E4%BE%8B%E5%AD%90\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例子</h2>\n<p>举例来说 这样的一个组件：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span><span class=\"token punctuation\">></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n      {{ msg }}\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ChildComponent</span> <span class=\"token punctuation\">/></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>我们在触发 <code class=\"language-text\">this.msg = &#39;Hello, Changed~&#39;</code>的时候，会触发组件的更新，视图的重新渲染。</p>\n<p>但是 <code class=\"language-text\">&lt;ChildComponent  /&gt;</code> 这个组件其实是不会重新渲染的，这是 Vue 刻意而为之的。</p>\n<p>在以前的一段时间里，我曾经认为因为组件是一棵树，所以它的更新就是理所当然的深度遍历这棵树，进行递归更新。本篇就从源码的角度带你一起分析，Vue 是怎么做到<code class=\"language-text\">精确更新</code>的。</p>\n<h2 id=\"react的更新粒度\"><a href=\"#react%E7%9A%84%E6%9B%B4%E6%96%B0%E7%B2%92%E5%BA%A6\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React的更新粒度</h2>\n<p>而 React 在类似的场景下是<code class=\"language-text\">自顶向下的进行递归更新的</code>，也就是说，React 中假如 <code class=\"language-text\">ChildComponent</code> 里还有十层嵌套子元素，那么所有层次都会递归的重新render（在不进行手动优化的情况下），这是性能上的灾难。（因此，React 创造了<code class=\"language-text\">Fiber</code>，创造了<code class=\"language-text\">异步渲染</code>，其实本质上是弥补被自己搞砸了的性能）。</p>\n<p>他们能用收集依赖的这套体系吗？不能，因为他们遵从<code class=\"language-text\">Immutable</code>的设计思想，永远不在原对象上修改属性，那么基于 <code class=\"language-text\">Object.defineProperty</code> 或 <code class=\"language-text\">Proxy</code> 的响应式依赖收集机制就无从下手了（你永远返回一个新的对象，我哪知道你修改了旧对象的哪部分？）</p>\n<p>同时，由于没有响应式的收集依赖，React 只能递归的把所有子组件都重新 <code class=\"language-text\">render</code>一遍，然后再通过 <code class=\"language-text\">diff算法</code> 决定要更新哪部分的视图，这个递归的过程叫做 <code class=\"language-text\">reconciler</code>，听起来很酷，但是性能很灾难。</p>\n<h2 id=\"vue的更新粒度\"><a href=\"#vue%E7%9A%84%E6%9B%B4%E6%96%B0%E7%B2%92%E5%BA%A6\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vue的更新粒度</h2>\n<p>那么，Vue 这种精确的更新是怎么做的呢？其实每个组件都有自己的<code class=\"language-text\">渲染 watcher</code>，它掌管了当前组件的视图更新，但是并不会掌管 <code class=\"language-text\">ChildComponent</code> 的更新。</p>\n<p>具体到源码中，是怎么样实现的呢？</p>\n<p>在 <code class=\"language-text\">patch</code>  的过程中，当组件更新到<code class=\"language-text\">ChildComponent</code>的时候，会走到\n<code class=\"language-text\">patchVnode</code>，那么这个方法大致做了哪些事情呢？</p>\n<h3 id=\"patchvnode\"><a href=\"#patchvnode\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>patchVnode</h3>\n<h4 id=\"执行-vnode-的-prepatch-钩子。\"><a href=\"#%E6%89%A7%E8%A1%8C-vnode-%E7%9A%84-prepatch-%E9%92%A9%E5%AD%90%E3%80%82\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>执行 <code class=\"language-text\">vnode</code> 的 <code class=\"language-text\">prepatch</code> 钩子。</h4>\n<p>注意，只有 <code class=\"language-text\">组件vnode</code> 才会有 <code class=\"language-text\">prepatch</code> 这个生命周期，</p>\n<p>这里会走到<code class=\"language-text\">updateChildComponent</code>方法，这个 <code class=\"language-text\">child</code> 具体指什么呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token function\">prepatch</span> <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> options <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>componentOptions\n    <span class=\"token comment\">// 注意 这个child就是ChildComponent组件的 vm 实例，也就是咱们平常用的 this</span>\n    <span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>componentInstance <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>componentInstance\n    <span class=\"token function\">updateChildComponent</span><span class=\"token punctuation\">(</span>\n      child<span class=\"token punctuation\">,</span>\n      options<span class=\"token punctuation\">.</span>propsData<span class=\"token punctuation\">,</span> <span class=\"token comment\">// updated props</span>\n      options<span class=\"token punctuation\">.</span>listeners<span class=\"token punctuation\">,</span> <span class=\"token comment\">// updated listeners</span>\n      vnode<span class=\"token punctuation\">,</span> <span class=\"token comment\">// new parent vnode</span>\n      options<span class=\"token punctuation\">.</span>children <span class=\"token comment\">// new children</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p>其实看传入的参数也能猜到大概了，就是做了：</p>\n<ol>\n<li>更新props（后续详细讲）</li>\n<li>更新绑定事件</li>\n<li>对于slot做一些更新（后续详细讲）</li>\n</ol>\n<h4 id=\"如果有子节点的话，对子节点进行-diff。\"><a href=\"#%E5%A6%82%E6%9E%9C%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%AF%B9%E5%AD%90%E8%8A%82%E7%82%B9%E8%BF%9B%E8%A1%8C-diff%E3%80%82\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>如果有子节点的话，对子节点进行 diff。</h4>\n<p>比如这样的场景：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>3<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>要对于 <code class=\"language-text\">ul</code> 中的三个 <code class=\"language-text\">li</code> 子节点 <code class=\"language-text\">vnode</code> 利用 <code class=\"language-text\">diff</code> 算法来更新，本篇略过。</p>\n<p>然后到此为止，<code class=\"language-text\">patchVnode</code> 就结束了，并没有像常规思维中的那样去递归的更新子组件树。</p>\n<p>这也就说明了，<strong>Vue 的组件更新确实是精确到组件本身的</strong>。</p>\n<h3 id=\"props的更新如何触发重渲染？\"><a href=\"#props%E7%9A%84%E6%9B%B4%E6%96%B0%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E9%87%8D%E6%B8%B2%E6%9F%93%EF%BC%9F\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>props的更新如何触发重渲染？</h3>\n<p>那么有同学可能要问了，如果我们把 <code class=\"language-text\">msg</code> 这个响应式元素通过props传给 <code class=\"language-text\">ChildComponent</code>，此时它怎么更新呢？</p>\n<p>其实，<code class=\"language-text\">msg</code> 在传给子组件的时候，会被保存在子组件实例的 <code class=\"language-text\">_props</code> 上，并且被定义成了<code class=\"language-text\">响应式属性</code>，而子组件的模板中对于 <code class=\"language-text\">msg</code> 的访问其实是被代理到 <code class=\"language-text\">_props.msg</code> 上去的，所以自然也能精确的收集到依赖，只要 <code class=\"language-text\">ChildComponent</code> 在模板里也读取了这个属性。</p>\n<p>这里要注意一个细节，其实父组件发生重渲染的时候，是会重新计算子组件的 <code class=\"language-text\">props</code> 的，具体是在 <code class=\"language-text\">updateChildComponent</code> 中的：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token comment\">// update props</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>propsData <span class=\"token operator\">&amp;&amp;</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">toggleObserving</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 注意props被指向了 _props</span>\n    <span class=\"token keyword\">const</span> props <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_props\n    <span class=\"token keyword\">const</span> propKeys <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>_propKeys <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> propKeys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> propKeys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">const</span> propOptions<span class=\"token punctuation\">:</span> any <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>props <span class=\"token comment\">// wtf flow?</span>\n      <span class=\"token comment\">// 就是这句话，触发了对于 _props.msg 的依赖更新。</span>\n      props<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">validateProp</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> propOptions<span class=\"token punctuation\">,</span> propsData<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">toggleObserving</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// keep a copy of raw propsData</span>\n    vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>propsData <span class=\"token operator\">=</span> propsData\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么，由于上面注释标明的那段代码，<code class=\"language-text\">msg</code> 的变化通过 <code class=\"language-text\">_props</code> 的响应式能力，也让子组件重新渲染了，到目前为止，都只有真的用到了 <code class=\"language-text\">msg</code> 的组件被重新渲染了。</p>\n<p>正如官网 api 文档中所说：</p>\n<blockquote>\n<p><code class=\"language-text\">vm.$forceUpdate</code>：迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。\n—— <a href=\"https://cn.vuejs.org/v2/api/#vm-forceUpdate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">vm-forceUpdate文档</a></p>\n</blockquote>\n<p>我们需要知道一个小知识点，<code class=\"language-text\">vm.$forceUpdate</code> 本质上就是触发了<code class=\"language-text\">渲染watcher</code>的重新执行，和你去修改一个响应式的属性触发更新的原理是一模一样的，它只是帮你调用了 <code class=\"language-text\">vm._watcher.update()</code>（只是提供给你了一个便捷的api，在设计模式中叫做<code class=\"language-text\">门面模式</code>）</p>\n<h3 id=\"slot是怎么更新的？\"><a href=\"#slot%E6%98%AF%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E7%9A%84%EF%BC%9F\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>slot是怎么更新的？</h3>\n<p>注意这里也提到了一个细节，也就是 <code class=\"language-text\">插入插槽内容的子组件</code>：</p>\n<p>举例来说</p>\n<p>假设我们有父组件<code class=\"language-text\">parent-comp</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>slot-comp</span><span class=\"token punctuation\">></span></span>\n     <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span>{{ msg }}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>slot-comp</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>子组件 <code class=\"language-text\">slot-comp</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>slot</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>slot</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>组件中含有 <code class=\"language-text\">slot</code>的更新 ，是属于比较特殊的场景。</p>\n<p>这里的 <code class=\"language-text\">msg</code> 属性在进行依赖收集的时候，收集到的是 <code class=\"language-text\">parent-comp</code> 的`渲染watcher。（至于为什么，你看一下它所在的渲染上下文就懂了。）</p>\n<p>那么我们想象 <code class=\"language-text\">msg</code> 此时更新了，</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>slot-comp</span><span class=\"token punctuation\">></span></span>\n     <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span>{{ msg }}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>slot-comp</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>这个组件在更新的时候，遇到了一个子组件 <code class=\"language-text\">slot-comp</code>，按照 Vue 的精确更新策略来说，子组件是不会重新渲染的。</p>\n<p>但是在源码内部，它做了一个判断，在执行 <code class=\"language-text\">slot-comp</code> 的 <code class=\"language-text\">prepatch</code> 这个hook的时候，会执行 <code class=\"language-text\">updateChildComponent</code> 逻辑，在这个函数内部会发现它有 <code class=\"language-text\">slot</code> 元素。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token function\">prepatch</span> <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> options <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>componentOptions\n    <span class=\"token comment\">// 注意 这个child就是 slot-comp 组件的 vm 实例，也就是咱们平常用的 this</span>\n    <span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>componentInstance <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>componentInstance\n    <span class=\"token function\">updateChildComponent</span><span class=\"token punctuation\">(</span>\n      child<span class=\"token punctuation\">,</span>\n      options<span class=\"token punctuation\">.</span>propsData<span class=\"token punctuation\">,</span> <span class=\"token comment\">// updated props</span>\n      options<span class=\"token punctuation\">.</span>listeners<span class=\"token punctuation\">,</span> <span class=\"token comment\">// updated listeners</span>\n      vnode<span class=\"token punctuation\">,</span> <span class=\"token comment\">// new parent vnode</span>\n      options<span class=\"token punctuation\">.</span>children <span class=\"token comment\">// new children</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p>在 <code class=\"language-text\">updateChildComponent</code> 内部</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token keyword\">const</span> hasChildren <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>\n    <span class=\"token comment\">// 这玩意就是 slot 元素</span>\n    renderChildren <span class=\"token operator\">||</span>               <span class=\"token comment\">// has new static slots</span>\n    vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>_renderChildren <span class=\"token operator\">||</span>  <span class=\"token comment\">// has old static slots</span>\n    parentVnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>scopedSlots <span class=\"token operator\">||</span> <span class=\"token comment\">// has new scoped slots</span>\n    vm<span class=\"token punctuation\">.</span>$scopedSlots <span class=\"token operator\">!==</span> emptyObject <span class=\"token comment\">// has old scoped slots</span>\n  <span class=\"token punctuation\">)</span></code></pre></div>\n<p>然后下面走一个判断</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hasChildren<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vm<span class=\"token punctuation\">.</span>$slots <span class=\"token operator\">=</span> <span class=\"token function\">resolveSlots</span><span class=\"token punctuation\">(</span>renderChildren<span class=\"token punctuation\">,</span> parentVnode<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">)</span>\n    vm<span class=\"token punctuation\">.</span><span class=\"token function\">$forceUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里调用了 <code class=\"language-text\">slot-comp</code> 组件vm实例上的 <code class=\"language-text\">$forceUpdate</code>，那么它所触发的<code class=\"language-text\">渲染watcher</code>就是属于<code class=\"language-text\">slot-comp</code>的<code class=\"language-text\">渲染watcher</code>了。  </p>\n<p>总结来说，这次 <code class=\"language-text\">msg</code> 的更新不光触发了 <code class=\"language-text\">parent-comp</code> 的重渲染，也进一步的触发了拥有slot的子组件 <code class=\"language-text\">slot-comp</code> 的重渲染。  </p>\n<p>它也只是触发了两层渲染，如果 <code class=\"language-text\">slot-comp</code> 内部又渲染了其他组件 <code class=\"language-text\">slot-child</code>，那么此时它是不会进行递归更新的。（只要 <code class=\"language-text\">slot-child</code> 组件不要再有 slot 了）。</p>\n<p>比起 React 的递归更新，是不是还是好上很多呢？</p>\n<h2 id=\"赠礼-一个小issue\"><a href=\"#%E8%B5%A0%E7%A4%BC-%E4%B8%80%E4%B8%AA%E5%B0%8Fissue\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>赠礼 一个小issue</h2>\n<p>有人给 Vue 2.4.2 版本提了一个<a href=\"https://github.com/vuejs/vue/issues/7573\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">issue</a>，在下面的场景下会出现 bug。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> Child <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"child\"</span><span class=\"token punctuation\">,</span>\n  template<span class=\"token punctuation\">:</span>\n    <span class=\"token string\">'&lt;div>&lt;span>{{ localMsg }}&lt;/span>&lt;button @click=\"change\">click&lt;/button>&lt;/div>'</span><span class=\"token punctuation\">,</span>\n  data<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      localMsg<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>msg\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    msg<span class=\"token punctuation\">:</span> String\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">change</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">$emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"update:msg\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  el<span class=\"token punctuation\">:</span> <span class=\"token string\">\"#app\"</span><span class=\"token punctuation\">,</span>\n  template<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;child :msg.sync=\"msg\">&lt;child>'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">beforeUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"update twice\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      msg<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hello\"</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  components<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    Child\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>具体的表现是点击 <code class=\"language-text\">click按钮</code>，会 alert 出两次 <code class=\"language-text\">update twice</code>。 这是由于子组件在执行 <code class=\"language-text\">data</code> 这个函数初始化组件的数据时，会错误的再收集一遍 <code class=\"language-text\">Dep.target</code> （也就是<code class=\"language-text\">渲染watcher</code>）。</p>\n<p>由于数据初始化的时机是 <code class=\"language-text\">beforeCreated</code> -> <code class=\"language-text\">created</code> 之间，此时由于还没有进入子组件的渲染阶段， <code class=\"language-text\">Dep.target</code> 还是父组件的<code class=\"language-text\">渲染watcher</code>。</p>\n<p>这就导致重复收集依赖，重复触发同样的更新，具体表现可以看这里：<a href=\"https://jsfiddle.net/sbmLobvr/9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jsfiddle.net/sbmLobvr/9</a> 。</p>\n<p>怎么解决的呢？很简单，在执行 <code class=\"language-text\">data</code> 函数的前后，把 <code class=\"language-text\">Dep.target</code> 先设置为 null 即可，在 <code class=\"language-text\">finally</code> 中再恢复，这样响应式数据就没办法收集到依赖了。</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">export function getData (data: Function, vm: Component): any {\n  const prevTarget = Dep.target\n<span class=\"token inserted\">+ Dep.target = null</span>\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, `data()`)\n    return {}\n<span class=\"token inserted\">+ } finally {</span>\n<span class=\"token inserted\">+   Dep.target = prevTarget</span>\n  }\n}</code></pre></div>\n<h2 id=\"后记\"><a href=\"#%E5%90%8E%E8%AE%B0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>后记</h2>\n<p>如果你对于 <code class=\"language-text\">Dep.target</code>、 <code class=\"language-text\">渲染watcher</code>等概念还不太理解，可以看我写的一篇最简实现 Vue 响应式的文章，欢迎阅读：</p>\n<p><a href=\"https://juejin.im/post/5db6433b51882564912fc30f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">手把手带你实现一个最精简的响应式系统来学习Vue的data、computed、watch源码</a></p>\n<p>本文也存放在<a href=\"https://github.com/sl1673495/blogs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">我的Github博客仓库</a>中，欢迎订阅和star。</p>\n<h2 id=\"鸣谢\"><a href=\"#%E9%B8%A3%E8%B0%A2\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>鸣谢</h2>\n<p>感谢 <a href=\"https://github.com/theniceangel\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">嵇智</a> 大佬对于本文一些细节的纠正。</p>","timeToRead":10,"frontmatter":{"title":"Vue 和 React 对于组件的更新粒度有什么区别？","date":"April 01, 2020","spoiler":""},"fields":{"slug":"/591974262/","langKey":"en"}}},"pageContext":{"slug":"/591974262/","previous":{"fields":{"slug":"/588385836/","langKey":"en","directoryName":"588385836"},"frontmatter":{"title":"前端高级进阶指南"}},"next":{"fields":{"slug":"/592778801/","langKey":"en","directoryName":"592778801"},"frontmatter":{"title":"为什么 Vue 中不要用 index 作为 key？（diff 算法详解）"}},"translations":[],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}