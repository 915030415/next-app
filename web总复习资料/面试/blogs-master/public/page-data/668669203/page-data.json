{"componentChunkName":"component---src-templates-blog-post-js","path":"/668669203/","result":{"data":{"site":{"siteMetadata":{"title":"ssh的博客","author":"ssh"}},"markdownRemark":{"id":"adff9857-6d44-5572-82dd-8b6d30da04ac","html":"<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>TypeScript 中有很多地方涉及到子类型 <code class=\"language-text\">subtype</code>、父类型 <code class=\"language-text\">supertype</code>、逆变和协变<code class=\"language-text\">covariance and contravariance</code>的概念，如果搞不清这些概念，那么很可能被报错搞的无从下手，或者在写一些复杂类型的时候看到别人可以这么写，但是不知道为什么他可以生效。（就是我自己没错了）</p>\n<h2 id=\"子类型\"><a href=\"#%E5%AD%90%E7%B1%BB%E5%9E%8B\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>子类型</h2>\n<p>比如考虑如下接口：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Dog</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">bark</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在这个例子中，<code class=\"language-text\">Animal</code> 是 <code class=\"language-text\">Dog</code> 的父类，<code class=\"language-text\">Dog</code>是<code class=\"language-text\">Animal</code>的子类型，子类型的属性比父类型更多，更具体。</p>\n<ul>\n<li>在类型系统中，属性更多的类型是子类型。</li>\n<li>在集合论中，属性更少的集合是子集。</li>\n</ul>\n<p>也就是说，子类型是父类型的超集，而父类型是子类型的子集，这是直觉上容易搞混的一点。</p>\n<p>记住一个特征，子类型比父类型更加<strong>具体</strong>，这点很关键。</p>\n<h2 id=\"可赋值性-assignable\"><a href=\"#%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7-assignable\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>可赋值性 <code class=\"language-text\">assignable</code></h2>\n<p><code class=\"language-text\">assignable</code> 是类型系统中很重要的一个概念，当你把一个变量赋值给另一个变量时，就要检查这两个变量的类型之间是否可以相互赋值。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> animal<span class=\"token punctuation\">:</span> Animal\n<span class=\"token keyword\">let</span> dog<span class=\"token punctuation\">:</span> Dog\n\nanimal <span class=\"token operator\">=</span> dog <span class=\"token comment\">// ✅ok</span>\ndog <span class=\"token operator\">=</span> animal <span class=\"token comment\">// ❌error! animal 实例上缺少属性 'bark'</span></code></pre></div>\n<p>从这个例子里可以看出，<code class=\"language-text\">animal</code> 是一个「更宽泛」的类型，它的属性比较少，所以更「具体」的子类型是可以赋值给它的，因为你是知道 <code class=\"language-text\">animal</code> 上只有 <code class=\"language-text\">age</code> 这个属性的，你只会去使用这个属性，<code class=\"language-text\">dog</code> 上拥有 <code class=\"language-text\">animal</code> 所拥有的一切类型，赋值给 <code class=\"language-text\">animal</code> 是不会出现类型安全问题的。</p>\n<p>反之，如果 <code class=\"language-text\">dog = animal</code>，那么后续使用者会期望 <code class=\"language-text\">dog</code> 上拥有 <code class=\"language-text\">bark</code> 属性，当他调用了 <code class=\"language-text\">dog.bark()</code> 就会引发运行时的崩溃。</p>\n<p>从可赋值性角度来说，子类型是可以赋值给父类型的，也就是 <code class=\"language-text\">父类型变量 = 子类型变量</code> 是安全的，因为子类型上涵盖了父类型所拥有的的一切属性。</p>\n<p>当我初学的时候，我会觉得 <code class=\"language-text\">T extends {}</code> 这样的语句很奇怪，为什么可以 <code class=\"language-text\">extends</code> 一个空类型并且在传递任意类型时都成立呢？当搞明白上面的知识点，这个问题也自然迎刃而解了。</p>\n<h2 id=\"在函数中的运用\"><a href=\"#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>在函数中的运用</h2>\n<p>假设我们有这样的一个函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>有这样两个变量：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> val1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> val2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>调用 <code class=\"language-text\">f(val1)</code> 是会报错的，比较显而易见的来看是因为缺少属性 <code class=\"language-text\">b</code>，而函数 <code class=\"language-text\">f</code> 中很可能去访问 <code class=\"language-text\">b</code> 属性并且做一些操作，比如 <code class=\"language-text\">b.substr()</code>，这就会导致崩溃。</p>\n<p>换成上面的知识点来看，<code class=\"language-text\">val1</code> 对应的类型是<code class=\"language-text\">{ a: number }</code>，它是 <code class=\"language-text\">{ a: number, b: number }</code> 的父类型，调用 <code class=\"language-text\">f(val1)</code> 其实就相当于把函数定义中的形参 <code class=\"language-text\">val</code> 赋值成了 <code class=\"language-text\">val1</code>，\n把父类型的变量赋值给子类型的变量，这是危险的。</p>\n<p>反之，调用 <code class=\"language-text\">f(val2)</code> 没有任何问题，因为 <code class=\"language-text\">val2</code> 的类型是 <code class=\"language-text\">val</code>类型的子类型，它拥有更多的属性，函数有可能使用的一切属性它都有。</p>\n<p>假设我现在要开发一个 <code class=\"language-text\">redux</code>，在声明 <code class=\"language-text\">dispatch</code> 类型的时候，我就可以这样去做：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Action</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">type</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> dispatch<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Action</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这样，就约束了传入的参数一定是 <code class=\"language-text\">Action</code> 的子类型。也就是说，必须有 <code class=\"language-text\">type</code>，其他的属性有没有，您随意。</p>\n<h2 id=\"在联合类型中的运用\"><a href=\"#%E5%9C%A8%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>在联合类型中的运用</h2>\n<p>学习了以上知识点，再看联合类型的可赋值性，乍一看会比较反直觉， <code class=\"language-text\">&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 是 <code class=\"language-text\">&#39;a&#39; | &#39;b&#39;</code> 的子类型吗？它看起来属性更多诶？其实正相反，<code class=\"language-text\">&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 是 <code class=\"language-text\">&#39;a&#39; | &#39;b&#39;</code> 的父类型。因为前者比后者更「宽泛」，后者比前者更「具体」。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> Parent <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'b'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'c'</span>\n<span class=\"token keyword\">type</span> Son <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'b'</span>\n\n<span class=\"token keyword\">let</span> parent<span class=\"token punctuation\">:</span> Parent\n<span class=\"token keyword\">let</span> son<span class=\"token punctuation\">:</span> Son\n\nparent <span class=\"token operator\">=</span> son <span class=\"token comment\">// ✅ok</span>\nson <span class=\"token operator\">=</span> parent <span class=\"token comment\">// ❌error! parent 有可能是 'c'</span></code></pre></div>\n<p>这里 <code class=\"language-text\">son</code> 是可以安全的赋值给 <code class=\"language-text\">parent</code> 的，因为 <code class=\"language-text\">son</code> 的所有可能性都被 <code class=\"language-text\">parent</code> 涵盖了。</p>\n<p>而反之则不行，<code class=\"language-text\">parent</code> 太宽泛了，它有可能是 <code class=\"language-text\">&#39;c&#39;</code>，这是 <code class=\"language-text\">Son</code> 类型 hold 不住的。</p>\n<p>这个例子看完以后，你应该可以理解为什么 <code class=\"language-text\">&#39;a&#39; | &#39;b&#39; extends &#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 为 true 了，在书写 <code class=\"language-text\">conditional types</code>的时候更加灵活的运用吧。</p>\n<h2 id=\"逆变和协变\"><a href=\"#%E9%80%86%E5%8F%98%E5%92%8C%E5%8D%8F%E5%8F%98\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>逆变和协变</h2>\n<p>先来段<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">维基百科的定义</a>：</p>\n<blockquote>\n<p>协变与逆变(covariance and contravariance)是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p>\n</blockquote>\n<p>描述的比较晦涩难懂，但是用我们上面的动物类型的例子来解释一波，现在我们还是有 <code class=\"language-text\">Animal</code> 和 <code class=\"language-text\">Dog</code> 两个父子类型。</p>\n<h3 id=\"协变（covariance）\"><a href=\"#%E5%8D%8F%E5%8F%98%EF%BC%88covariance%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>协变（Covariance）</h3>\n<p>那么想象一下，现在我们分别有这两个子类型的数组，他们之间的父子关系应该是怎么样的呢？没错，<code class=\"language-text\">Animal[]</code> 依然是 <code class=\"language-text\">Dog[]</code> 的父类型，对于这样的一段代码，把子类型赋值给父类型依然是安全的：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> animals<span class=\"token punctuation\">:</span> Animal<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">let</span> dogs<span class=\"token punctuation\">:</span> Dog<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\nanimals <span class=\"token operator\">=</span> dogs\n\nanimals<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>age <span class=\"token comment\">// ✅ok</span></code></pre></div>\n<p>转变成数组之后，对于父类型的变量，我们依然只会去 <code class=\"language-text\">Dog</code> 类型中一定有的那些属性。</p>\n<p>那么，对于 <code class=\"language-text\">type MakeArray&lt;T&gt; = T[]</code> 这个类型构造器来说，它就是 <strong><code class=\"language-text\">协变（Covariance）</code></strong> 的。</p>\n<h3 id=\"逆变（contravariance）\"><a href=\"#%E9%80%86%E5%8F%98%EF%BC%88contravariance%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>逆变（Contravariance）</h3>\n<p>有这样两个函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">visitAnimal</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">:</span> Animal<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">visitDog</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>dog<span class=\"token punctuation\">:</span> Dog<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">animal = dog</code> 是类型安全的，那么 <code class=\"language-text\">visitAnimal = visitDog</code> 好像也是可行的？其实不然，想象一下这两个函数的实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">visitAnimal</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">:</span> Animal<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  animal<span class=\"token punctuation\">.</span>age\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">visitDog</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>dog<span class=\"token punctuation\">:</span> Dog<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  dog<span class=\"token punctuation\">.</span>age\n  dog<span class=\"token punctuation\">.</span><span class=\"token function\">bark</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>由于 <code class=\"language-text\">visitDog</code> 的参数期望的是一个更具体的带有 <code class=\"language-text\">bark</code> 属性的子类型，所以如果 <code class=\"language-text\">visitAnimal = visitDog</code> 后，我们可能会用一个不带 <code class=\"language-text\">bark</code> 属性的普通的 <code class=\"language-text\">animal</code> 类型来传给 <code class=\"language-text\">visitDog</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">visitAnimal <span class=\"token operator\">=</span> visitDog\n\n<span class=\"token keyword\">let</span> animal <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> age<span class=\"token punctuation\">:</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">visitAnimal</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token comment\">// ❌</span></code></pre></div>\n<p>这会造成运行时错误，<code class=\"language-text\">animal.bark</code> 根本不存在，去调用这个方法会引发崩溃。</p>\n<p>但是反过来，<code class=\"language-text\">visitDog = visitAnimal</code> 却是完全可行的。因为后续调用方会传入一个比 <code class=\"language-text\">animal</code> 属性更具体的 <code class=\"language-text\">dog</code>，函数体内部的一切访问都是安全的。</p>\n<p>在对 <code class=\"language-text\">Animal</code> 和 <code class=\"language-text\">Dog</code> 类型分别调用如下的类型构造器之后：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> MakeFunction<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span></code></pre></div>\n<p>父子类型关系逆转了，这就是 <strong><code class=\"language-text\">逆变（Contravariance）</code></strong>。</p>\n<h2 id=\"在-ts-中\"><a href=\"#%E5%9C%A8-ts-%E4%B8%AD\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>在 TS 中</h2>\n<p>当然，在 TypeScript 中，由于灵活性等权衡，对于函数参数默认的处理是 <code class=\"language-text\">双向协变</code> 的。也就是既可以 <code class=\"language-text\">visitAnimal = visitDog</code>，也可以 <code class=\"language-text\">visitDog = visitAnimal</code>。在开启了 <code class=\"language-text\">tsconfig</code> 中的 <code class=\"language-text\">strictFunctionType</code> 后才会严格按照 <code class=\"language-text\">逆变</code> 来约束赋值关系。</p>\n<h2 id=\"结语\"><a href=\"#%E7%BB%93%E8%AF%AD\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结语</h2>\n<p>这篇文章结合我自己最近学习类型相关知识的一些心得整理而成，如果有错误或者疏漏欢迎大家指出。</p>\n<h2 id=\"参考资料\"><a href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考资料</h2>\n<p><a href=\"https://flow.org/en/docs/lang/subtypes/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Subsets &#x26; Subtypes</a></p>\n<p><a href=\"https://www.staging-typescript.org/docs/handbook/type-compatibility.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TypeScript 官方文档</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">维基百科-协变与逆变</a></p>","timeToRead":7,"frontmatter":{"title":"TypeScript 中的子类型、逆变、协变是什么？","date":"July 30, 2020","spoiler":""},"fields":{"slug":"/668669203/","langKey":"en"}}},"pageContext":{"slug":"/668669203/","previous":{"fields":{"slug":"/652239833/","langKey":"en","directoryName":"652239833"},"frontmatter":{"title":"前端算法进阶指南"}},"next":{"fields":{"slug":"/678385574/","langKey":"en","directoryName":"678385574"},"frontmatter":{"title":"一道蚂蚁金服异步串行面试题"}},"translations":[],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}